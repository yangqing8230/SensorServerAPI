# 无线电监测服务开发说明 v1.0

## 概述

该文档介绍无线电监测系统的编程接口，指导开发者进行二次开发，构建自己的无线电监测应用程序。系统的接口基于protobuf和gRPC技术，采用语言中立的proto文件描述接口及消息。开发者可以根据个人喜好选择开发语言和开发环境。

## 典型C++/Qt环境搭建

### 依赖项

- Win7、Win10操作系统
- VS2015 update3 
- Qt5.7或以上
- vcpkg

### C++ API生成

- 双击运行`probuf-compile.bat`，把生成的.h和.cc文件拷贝到自己的工程目录下

- 在自己的工程中添加宏定义`_WIN32_WINNT=0x0600`

  其他方面请参考https://grpc.io/docs/tutorials/basic/cpp

建议开发者先了解熟悉protobuf和gRPC的相关技术，再进行二次开发。

## 接口说明

系统提供的接口，分布于`rf_node.proto、spectrum.proto、analog_demod.proto、tdoa.proto`四个文件中。其中`rf_node.proto`文件描述了通用的消息类型和传感网络管理接口，`spectrum.proto`、`analog_demod.proto`和`tdoa.proto`分别描述了频谱扫描、模拟解调、TDOA定位这三个任务的消息类型和接口。

### rf_node.proto

该文件包含三个接口：

```protobuf
service RFNodeService {
  rpc ListAllNodes(google.protobuf.Empty) returns (NodesInfo) {}
  rpc GetNodeInfo(NodeId) returns (NodeInfo) {}
  rpc NodeControl(NodeControlRequest) returns (NodeReply) {}
}
```

其中`ListAllNodes()`接口用于获取目前所有在线的传感器节点信息，`GetNodeInfo()`接口获得指定传感器的节点信息，`NodeControl`接口用于节点控制，比如操纵节点重启，停止所有运行中的任务等。

其中的`NodeInfo`是一个`protobuf`消息，定义如下

```protobuf
message NodeInfo {
  NodeId id = 1;		//节点id
  string name = 2;		//节点名字
  Timestamp last_heard_time = 3;	//最后一次得到数据包的时刻
  Position position = 4;			//节点位置
  repeated DeviceId devices = 5;	//节点挂接的设备列表
  repeated TaskSummary tasks = 6;	//节点正在运行的任务列表
}
```

### Spectrum.proto

该文件定义了系统频谱监测功能的消息和接口，包含7个服务接口：

```protobuf
service SpectrumService {
  rpc StartSweep(StartSweepRequest) returns (TaskAccount) {}
  rpc GetResult(TaskId) returns (stream SweepResult) {}
  rpc ChangeRange(ChangeRangeRequest) returns (NodeReply) {}
  rpc StopSweep(TaskId) returns (NodeReply) {}
  rpc StartRecord(TaskAccount) returns (NodeReply) {}
  rpc StopRecord(TaskAccount) returns (NodeReply) {} 
  rpc Threshold(ThresholdRequest) returns (NodeReply) {}
}
```

1. `StartSweep()`用于发起一个频谱扫描任务，接口需要一个`StartSweepRequest`类型的消息作为请求，服务端会返回一个`TaskAccount`的消息作为响应。

`StartSweepRequest`消息定义如下：

```protobuf
message StartSweepRequest {
  repeated NodeDevice task_runner = 1;	//该任务的执行节点
  SweepParams sweep_params = 2;			//任务参数
}
```

`TaskAccount`任务账号消息定义如下：

```protobuf
message TaskAccount{
  TaskId task_id = 1;				//任务id
  repeated NodeDevice node_devices = 2; //正常响应的节点列表
}
```

​	任务发起的内部流程大致为：当客户端调用`StartSweep()`，向服务端发起任务请求，服务端会收到`StartSweepRequest`消息，服务端从中得到参与到该任务的传感器节点，就向所有这些节点发送任务参数，得到节点的正常响应后，服务端会将该节点id加到正常响应的节点列表中，并创建一个代表该任务的`task_id`，作为响应消息一并返回给客户端。

2. `GetResult()`用于获取该任务的数据。注意该接口的返回值是一个流式的消息，意味着接口将会持续的推送消息到客户端。

任务数据消息`SweepResult`定义如下：

```protobuf
message SweepResult {
  NodeDevice result_from = 1;	//数据来源，源自哪个节点
  SweepResultHeader header = 2;	//描述头
  SweepResultBuffer buffer = 3;	//数据体
}
```

描述头包括数据的时间戳，方位戳，顺序号等子消息，数据体包括频谱迹线、信号列表、门限等子消息。

3. `ChangeRange()`用于更改任务的频率范围。

`ChangeRangeRequest`消息定义如下：

```protobuf
message ChangeRangeRequest {
  TaskAccount task_account = 1;	//任务账号
  FrequencySpan span = 2;		//要设定的频率范围
}
```

从中可以看出，该请求向服务端发送了`TaskAccount`和一个待变更的频率范围，服务端在收到该消息后，将会根据`TaskAccount`所列的设备id，向相关的设备节点发送该频率变更指令，待所有节点响应后，会生成一个`NodeReply`消息，返回给客户端。`NodeReply`是一个`CmdHeader`消息的集合，反映了所有执行该请求的设备节点的响应结果，因为无法保证所有响应结果均为正常，所以客户端需要对这个响应结果进行解析，根据错误码来确定后续行为。可能遇到的响应错误情况包括`taskId`非法、频率范围参数非法、节点响应超时等。

响应结果`CmdHeader`消息定义如下

```protobuf
message CmdHeader{
  uint32 sequence_number = 1;	//指令顺序号
  ErrorType error_code = 2;		//错误码
  TaskId task_id = 3;			//任务id
  NodeDevice task_runner = 4;	//设备节点id
};
```

4. `StopSweep()`用于停止一项频谱扫描任务。接口以`TaskId`作为请求，服务端在收到请求后，会向参与该任务的所有节点发送停止命令，待节点响应后，向客户端返回`NodeReply`响应结果。可能遇到的响应错误情况包括`taskId`非法，节点响应超时等。
5. `StartRecord()`启动记录功能。该接口向服务端发送了`TaskAccount`，来说明需要开启记录的节点，服务端在收到消息后，会向相关节点发送指令，由节点端执行实际的数据记录（数据将记录在节点本地），待节点响应后，向客户端返回`NodeReply`响应结果。如果有节点已经开始记录或出现其他无法启动记录的情况，将体现在`NodeReply`的错误码中。
6. `StopRecord()`停止记录功能。该接口向服务端发送了`TaskAccount`，来说明需要停止记录的节点，服务端在收到消息后，会向相关节点发送指令，待节点响应后，向客户端返回`NodeReply`响应结果。如果有的节点之前并没有开启记录，节点则会忽略此操作，并回送响应的错误码。
7. `Threshold()`用于开启节点的门限判决功能。当门限开启后，该节点的监测结果中会加入超门限频段的信息。该接口的请求包含`TaskAccount`和一组`ThresholdPoint`。其中`ThresholdPoint`消息定义如下：

```protobuf
message ThresholdPoint{
  double frequency = 1;		//频率，单位Hz
  float level = 2;			//幅度，单位dBm
}
```

### TDOA.proto

该文件定义了系统TDOA功能的消息和接口，包含3个接口

```protobuf
service TDOAService {
  rpc StartTDOA(StartTDOARequest) returns (TaskAccount) {}
  rpc GetResult(TaskId) returns (stream TDOAResponse) {}
  rpc StopTDOA(TaskId) returns (NodeReply) {}
}
```

1. `StartTDOA()`用于发起一个TDOA任务，客户端通过该接口向服务端发送`StartTDOARequest`消息，服务端回送`TaskAccount`消息作为响应。

`StartTDOARequest`消息定义为：

```protobuf
message StartTDOARequest{
  repeated NodeDevice task_runner = 1;	//参与TDOA定位任务的节点集合
  TDOAParams task_parms = 2;	//任务参数
}
```

其中的第二项`TDOAParams`消息定义为：

```protobuf
message TDOAParams {
  repeated TargetSignal target_signals  = 1;	//待定位的信号列表
  Timestamp sync_acquire_time = 2;				//起始同步采集时刻
  uint32 interval_msec = 3;    					//采集间隔，毫秒为单位
}
```

`TDOAParams`其中的第一项为待定位目标信号的列表，其中的每一项为描述一个信号的消息`TargetSignal`

```protobuf
message TargetSignal {
  double center_freq = 1;	//信号中心频率
  double bandwidth = 2;		//信号带宽
  int32 num_iteration = 3;	//定位迭代次数
  int32 attenuation_gain = 4; 	//增益衰减
  int32 antenna = 5;			//天线端口
}
```

2. `GetResult()`用于持续的获取定位结果，请求的消息为任务id，注意该接口是一个流接口，当启动TDOA任务后，一次性调用该接口会持续收到服务端的响应，响应包含定位过程和定位结果消息，直到任务停止之后，该调用才会返回。

```protobuf
message TDOAResponse {
  TDOAResult tdoa_result = 1;	//定位结果
  TDOADetail detail = 2;		//定位过程数据
}
```

```protobuf
message TDOAResult {
  ResultHeader header = 1;		//定位结果描述头       
  repeated GeogCoord target_position = 2;	//目标位置
  Timestamp timestamp = 3;          //获取时间
  repeated Participator participators = 4;	//参与定位的节点    
}
```

定位的结果数据`TDOAResult`中最重要的一项是序号为2的`repeated GeogCoord target_position`，该项包含了目标位置（经纬度信息），注意该项为复数，可包含[0,2]个定位结果，如果定位结果有0个，说明没有解，如果定位结果有1个，说明有唯一解；如果定位有2个，说明存在模糊解。

定位的过程数据`TDOADetail`可以包含定位过程中产生的频谱迹线、IQ迹线、互相关曲线等过程数据。用户可以根据需要，决定是否显示这些细节。

3. `StopTDOA()`用于停止TDOA任务，客户端以任务id为参数调用该接口，服务端会向所有参与该TDOA任务的节点发送停止命令，待所有节点响应后，将响应结果以`NodeReply`消息形式返回给客户端。







